#ifndef NETTHREAD_H
#define NETTHREAD_H
#include <QThread>
#include <QTcpSocket>
class NetThread : public QThread
{
    Q_OBJECT
public:
    NetThread();
protected:
    // 在这里定义线程运行时需要执行的任务
    void run() override {
        // 线程执行的具体代码
        // 可以包括网络通信、复杂计算等操作
        QTcpSocket socket;
        socket.connectToHost("example.com", 80);

        if (socket.waitForConnected()) {
            printf("Connected to host");
            fflush(stdout);
            // 发送和接收数据的逻辑可以在这里处理
        } else {
            printf("Connection failed: %s\n", socket.errorString().toStdString().c_str());
            fflush(stdout);
        }

        // 线程执行完成后，退出线程事件循环
        quit();
    }

    /*
    线程安全性：确保在多线程环境中正确处理共享数据和资源，避免竞争条件和数据损坏。

    事件循环：在 run() 方法中，通常不需要手动管理事件循环（exec() 方法），除非你需要自定义线程的事件处理机制。
    */

    /*
    在 Qt 中，关联的槽函数会在发送信号的对象所属的线程中执行。这意味着：

    如果信号是由主线程中的对象发出的（例如一个 UI 组件），那么与该信号关联的槽函数将在主线程中执行。
    如果信号是由一个在后台线程中创建的对象发出的，那么与该信号关联的槽函数将在该后台线程中执行。
    这种行为确保了槽函数在其相关联的对象的上下文中执行，从而可以安全地访问对象的属性和方法，而不需要显式的线程同步措施（例如使用 QMutex 或 QWaitCondition）。
    */

    /*
    这句话的意思是，在一个继承自 QThread 的子类中的 run() 方法内部，通常不需要显式调用 exec() 方法来启动线程的事件循环。这是因为在 QThread 的默认实现中，当你调用 start() 启动线程时，Qt 已经在后台处理了事件循环的初始化和管理。

    具体来说：

    默认行为：当你调用 start() 启动一个继承自 QThread 的线程时，Qt 会在新线程中执行 run() 方法，并在其中启动事件循环，从而使线程能够响应事件和处理槽函数的调用。

    无需手动调用 exec()：因此，大部分情况下，你不需要在 run() 方法中手动调用 exec() 方法来启动事件循环。Qt 在启动线程时会自动完成这些工作，确保线程能够正常运行。

    自定义事件处理机制：然而，如果你需要实现更复杂的事件处理机制或者自定义事件循环行为，例如处理自定义事件队列或特定类型的事件，那么你可能需要在 run() 方法中手动管理事件循环，通过调用 exec() 来启动 Qt 的事件处理机制。

    总结来说，这段话提醒我们，在使用 QThread 时，通常不必关注事件循环的底层管理，除非你有特定的需求要自定义线程的事件处理方式。
    */



    /*
    在 Qt 中，exec() 是事件循环的入口函数，它负责处理和分发各种事件，确保程序能够响应用户操作和系统事件。具体来说，exec() 方法会做以下几件事情：

    处理事件队列： Qt 的事件循环会不断从事件队列中取出事件，并将这些事件分发给对应的接收者（通常是 QObject 的派生类）。

    事件分发： 将事件发送到合适的接收者。例如，当用户点击界面上的按钮时，Qt 会生成一个事件，并将其分发给按钮对象，按钮对象则会触发与之关联的槽函数。

    处理定时器事件： Qt 中的定时器事件（例如 QTimer）也是通过事件循环来处理的。exec() 方法会负责定期检查定时器是否到期并触发相应的定时器事件。

    系统事件处理： 包括操作系统级别的事件，如窗口移动、大小调整、关闭等。这些事件通过 Qt 的事件循环传递到对应的 Qt 对象中进行处理。

    退出机制： exec() 方法会等待直到退出条件满足，例如调用 QCoreApplication::quit() 或者关闭了主窗口。一旦退出条件满足，事件循环会终止，线程也会相应地退出。

    总之，exec() 是 Qt 应用程序的核心事件循环处理机制，它确保了程序能够有效地响应用户输入、系统事件和定时器事件。理解和正确使用 exec() 方法对于开发稳定、响应迅速的 Qt 应用程序至关重要。

    Qt的事件包括什么?
    在 Qt 中，事件是一种重要的通信机制，用于处理各种类型的输入、状态变化和系统通知。以下是 Qt 中常见的事件类型：

    用户界面事件（GUI 事件）：

    鼠标事件： 包括点击、移动、释放等。
    键盘事件： 捕获键盘按键的按下和释放。
    焦点事件： 控制控件的焦点状态变化。
    绘图事件： 控件需要重绘时产生的事件。
    拖放事件： 涉及拖放操作的事件。
    定时器事件： 通过 QTimer 等定时器对象生成的事件，用于实现定时执行某些操作。

    系统事件： 涵盖底层系统通知，例如窗口大小变化、窗口最小化、关闭窗口等。

    自定义事件： 可以由开发者创建的特定目的的事件，通过 QEvent 的子类来定义。

    网络事件： 用于处理网络通信的事件，例如数据接收或连接状态变化。

    状态事件： 用于通知对象的状态变化，如启用状态的改变等。

    在 Qt 中，这些事件通过事件循环 (QCoreApplication::exec() 或 QEventLoop::exec()) 分发和处理，确保应用程序能够有效地响应用户输入、系统通知和其他异步事件。理解和处理这些事件是编写响应式、高效的 Qt 应用程序的关键。


    */
};

#endif // NETTHREAD_H
